[
  {
    "id": "25ae9933-5fca-8076-97c5-c03d05e7e1fb",
    "created_time": "2025-08-25T10:13:00.000Z",
    "title": "You heard MongoDB follows ACID properties while other NoSQL DBs don’t. Do you know How and Why?",
    "date": "2025-08-24",
    "description": [
      {
        "component": "paragraph",
        "text": "TL;DR : NoSQL databases are BASE(Basically Available Soft State Eventually Consistent) by choice not by any limitation to NoSQL data storage format. ACID databases have a very specific use case in scenarios where consistency can’t be compromised say for Banking applications, Healthcare data storage. MongoDB tries to enter these use cases by being ACID. "
      },
      {
        "component": "paragraph",
        "text": "Long Answer : Unlike SQL databases, which were designed for single-node architectures, NoSQL databases must prioritize availability across multiple nodes. At scale, partition tolerance is a necessity if there’s a network outage between nodes, the database should still function. To achieve this, many NoSQL systems choose to be AP (Available and Partition-tolerant) as per the CAP theorem, since they cannot be fully consistent and AP at the same time."
      },
      {
        "component": "paragraph",
        "text": "But this still doesn’t explain why most NoSQL databases aren’t ACID. The term ACID, made popular by SQL databases, requires that a compliant database ensures:"
      },
      {
        "component": "numbered_list_item",
        "text": "Atomicity: In a transaction either all the operations are successful or none of them are."
      },
      {
        "component": "numbered_list_item",
        "text": "Consistency: After a transaction the DB should remain in a valid state, always respecting constraints such as schemas."
      },
      {
        "component": "numbered_list_item",
        "text": "Isolation: Every transaction should happen in Isolation, such that no other transaction is affected. This is often implemented using MVCC (Multi-Version Concurrency Control), which I’ll cover later."
      },
      {
        "component": "numbered_list_item",
        "text": "Durability: Once committed, a transaction is permanent and crash-safe, often implemented via Write-Ahead Logging (WAL), also discussed later."
      },
      {
        "component": "paragraph",
        "text": "By definition ACID appears a transaction specific property, no relationship with what it has to do with the database being SQL or NoSQL."
      },
      {
        "component": "paragraph",
        "text": "First thing an ACID database should have atomicity and durability which is often implemented using Write ahead logging(WAL) = a special sequential log file where all the changes are written before they are applied to the actual database. Secondly for Isolation, typically achieved through Multi version concurrency Control(MVCC) Instead of overwriting data mid-transaction, the database maintains multiple versions: one before the transaction and one after it completes. This ensures other operations aren’t affected by an incomplete transaction. A less common alternative is to enforce isolation using locking mechanisms."
      },
      {
        "component": "paragraph",
        "text": "These performance overheads are the reason most NoSQL databases, which focus on being lightweight and fast, drop full ACID compliance. And that makes sense actually, the majority of NoSQL use cases involve data where immediate consistency isn’t critical, such as likes, comment counts, or user profiles. In such scenarios, eventual consistency is perfectly acceptable. "
      },
      {
        "component": "paragraph",
        "text": "\nTo support consistency-sensitive use cases such as financial or healthcare data, MongoDB provides full ACID support by making key architectural changes:"
      },
      {
        "component": "numbered_list_item",
        "text": "Atomicity : MongoDB stores data in BSON format, where each document is a contiguous unit on the disk, making single-document updates atomic. It extends this further with multi-document transactions using Write-Ahead Logging (WAL). While most NoSQL databases (like Cassandra) ensure only document-level atomicity, MongoDB supports atomic operations across multiple documents."
      },
      {
        "component": "numbered_list_item",
        "text": "Consistency : Document-level consistency can be enforced through schemas. Note: this is different from the “consistency” defined in the CAP theorem."
      },
      {
        "component": "numbered_list_item",
        "text": "Isolation : MongoDB uses document-level locking for isolation. During transactions, it provides snapshot isolation, ensuring reads within a transaction see a stable view of the data."
      },
      {
        "component": "numbered_list_item",
        "text": "Durability : MongoDB uses a Write-Ahead Log (WAL) called WiredTiger, which provides a configurable property called WriteConcern to manage durability requirements, tunable by the user."
      },
      {
        "component": "paragraph",
        "text": "In short, MongoDB captures the benefits of an ACID-compliant database while keeping overhead minimal, whereas other NoSQL databases often prioritize raw speed and flexibility.\n\n"
      }
    ]
  },
  {
    "id": "25ae9933-5fca-808d-bad4-cf03990771c8",
    "created_time": "2025-08-25T10:12:00.000Z",
    "title": "20 million videos are uploaded to YouTube everyday, Figures for short form video content on instagram and tiktok are beyond comprehension. How do all these platforms handle this massive scale?",
    "date": "2025-08-23",
    "description": [
      {
        "component": "paragraph",
        "text": "When a user uploads a video, the media is chunked on the client. For example, a 200 MB file is split into 40 chunks of 5 MB each before the upload starts. Following that all the chunks are uploaded in parallel to increase upload speed. If a chunk upload fails during the process, only that specific chunk is retried, and once successful, it replaces the incomplete chunk in raw storage."
      },
      {
        "component": "paragraph",
        "text": "The first upload is done to the raw storage until further processing pipelines like transcoding are completed. Raw storage is basically a staging area for the media files and act as temporary buckets. "
      },
      {
        "component": "paragraph",
        "text": "Processing workers pick up the content from queues (Kafka/Pub/Sub) and transcode the videos into multiple bitrates (240p, 480p, 720p)"
      },
      {
        "component": "paragraph",
        "text": "After the processing is done the video chunks are now stored into object storage. Each object is of the format {data(blob), metadata, uniqueId}. Unlike local storage, object storage is designed for distributed environments. It uses a flat, non-hierarchical, key value store architecture, in contrast to the tree structures typically used on top of the local block storage."
      },
      {
        "component": "paragraph",
        "text": "A key benefit of object storage is that it avoids hotspots for popular videos by distributing chunks across nodes, which balances the load during access."
      },
      {
        "component": "paragraph",
        "text": "Videos go through a storage lifecycle. When freshly uploaded, they are pushed to CDNs and hot storage for fast access. As they age and demand drops, they move to cold storage, and eventually end up in archive storage."
      },
      {
        "component": "bulleted_list_item",
        "text": "Hot Storage → High IOPS (Input/Output per second). Expensive but very fast, typically backed by SSDs."
      },
      {
        "component": "bulleted_list_item",
        "text": "Cold Storage → Higher latency, backed by slower HDDs. Cheaper than hot storage."
      },
      {
        "component": "bulleted_list_item",
        "text": "Archive Storage → Retrieval takes minutes to hours, built on magnetic tapes and deep archive storage infra. Cheapest option."
      }
    ]
  }
]